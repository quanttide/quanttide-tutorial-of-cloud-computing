# Serverless简介

## 什么是Serverless？

Serverless（无服务）是相对于”有服务“的一个概念。这里的无服务是对开发者而言的，云厂商为开发者提供一套环境，开发者只需要把代码上传给云计算，云厂商即可帮助开发者完成所有部署服务的过程。从这个定义出发，广义的Serverless包括所有可以帮助开发者屏蔽部署服务过程的云服务。

狭义的Serverless则主要指AWS最早提出的解决方案Lambda及其衍生品，这套方案我们也称为**FaaS**（Function as a Service）。顾名思义，这是以函数为单位的解决方案，开发者只需要实现一个函数，就可以让云服务帮助自己完成上线应用的后续所有事情。这个函数我们称为”事件函数“，触发事件函数的东西我们成为”触发器“。这套模型具有很强的通用性和广泛的应用场景，理论上可以让函数和函数通信，也可以让函数和外部通信，因而受到广泛的关注和重视。

从软件架构的角度，我们经常把Serverless架构和微服务架构、单体服务架构比较，因为对于同样一个应用系统，单体服务使用一个服务实现；微服务则使用一群服务实现，每个服务都实现一个相对简单的功能，比如用户服务、订单服务等等。从软件架构上，Serverless可以看做细粒度更低的微服务，架构层面的业务单元不再是一个打包同一类功能的服务，而是一个函数组成的API接口。（从技术实现的角度，多个Serverless应用构成的服务依然是一个微服务；这里讨论的是抽象的软件架构问题，是从架构师的角度思考的。）细粒度更高的服务意味着更低的耦合度，这会带来更稳定的性能、更快的迭代效率，但也同时带来了更复杂的软件工程管理问题。目前已有一些初步的解决方案，比如AWS的Step Functions和阿里云的Serverless工作流（Serverless Workflow），都是很不错的解决方案。类似的方案普及以后，Serverless在很大程度上会代替微服务架构，成为下一代互联网应用的主流架构方案。

## 函数计算（FaaS）

函数计算引擎的工作原理是这样的：

1. 来自其他应用的**触发器**触发函数运行，并给函数传递必要的参数；
2. 函数的主函数是一个**事件函数**，接收参数并转换成函数内可以理解的数据格式；
3. 像其他程序一样运行函数内部的Native代码。

我们可以看到，触发器和事件函数是函数计算引擎的关键点，触发器发送消息，事件函数接收和解析消息，用以实现函数计算内外部的通信。最常见的触发器就是HTTP代理，触发器把HTTP报文解析并根据事件函数的传参规范传给事件函数，事件函数根据函数计算的标准解析并传给Native。通过这样的机制，我们可以很轻松地根据标准实现一个事件函数，然后使用云服务提供的函数计算框架部署成一个API接口。由于事件函数是通用的，理论上如果有合适的触发器和编排触发规则的工具，我们可以用它来做一些流程相对固定的应用和流水线，包括Web服务、爬虫、数据分析、机器学习等等。

### 事件函数

各家云厂商的事件函数规范，都直接follow了最早提出函数计算的AWS Lambda。我们以Python为例解析一个事件函数的规则。

Python的事件函数代码包必须包括一个执行入口（比如`index.py`），其中必须有一个事件函数的规范格式实现（比如`main`函数），具体格式如下：

```python
# index.py

def main(event, context):
    # do something
    return 'result'
```

其中，`event`参数的字面理解是“事件”，从名字可以知道这是触发器传递给事件函数的数据。（在事件驱动的编程中，所有的消息都是以“事件”为单位传递的。）如果是HTTP服务，则会把HTTP报文转换成`event`的参数。在Python中，`event`是一个`dict`格式。`context`参数字面意思是“上下文”，这里当然指的就是事件函数运行的上下文，也就是运行环境的信息。`return`返回值即是传递给触发器的返回值，根据触发器的加工即可变成其他程序需要的样子。比如，HTTP服务里会把返回值作为响应报文的body部分。

### 触发器

最常用的触发器是HTTP服务API，需要使用API网关触发器实现。API网关触发器根据预先配置的执行入口和事件函数（i.e. 本例的index.main），把请求报文转成事件给事件函数，接收返回值加工成响应报文。

各家云厂商除了支持HTTP服务，还会支持很多其他类型的触发器。比如对象存储触发器可以用来触发云函数做数据处理、图像和视频处理；消息队列触发器可以用来处理消息队列接收的消息；等等。

触发器为事件函数提供了和其他标准化应用的通信方式，让函数计算可以以灵活多样的方式接入其他应用，实现必要的功能。

### 底层实现

目前各家都是通过容器化部署函数计算环境来实现的。简而言之，在一个容器中打包这门语言所需要的运行环境（比如Python3.x），即可让这门语言的程序在容器内运行。

由于各家都是follow AWS的标准，AWS没有支持Python依赖的设置，所以各家都没有支持。这让Python依赖的打包不可以在云端部署时直接进行，对于使用者造成了很大的麻烦。

实际上这个问题在底层很容易解决，只需要根据Python规范，支持在根目录下设置requirements.txt，在Dockerfile中支持检查requirements.txt并运行`pip install -r requirements.txt`即可。

## 函数编排服务

现有的函数计算服务已经逐步标准和普及，而解决函数编排的方案还没有特别完善和普及。AWS Step Functions、阿里云的Serverless工作流（Serverless Workflow）和腾讯云的应用和服务编排工作流（Application Services Workflow，ASW）都是很好的解决方案，我们会简要介绍他们的解决思路。

前面我们提到，FaaS带来了更高的细粒度的同时，也带来了更大的工程管理难题。其中最大的难题是，当我们有几十个函数，函数和函数之间有一系列复杂的依赖关系，我们如何处理呢？我们先来举一些例子作为应用场景。

我们先说一些线性的步骤。爬虫服务比较简单，除去弹性资源调度（通常Serverless和云原生标准架构都内置），还需要”请求->解析->存储“这样一个相对固定的流水线。数据分析和机器学习的固定流程则通常是”数据清洗和预处理->特征提取->描述统计->模型分析->可视化“。

我们再举例一些非线性的步骤。Web服务（以Django为例）比较复杂，常见的执行过程是这样的。首先是一个处理HTTP和Web框架通信的协议，在Python中是WSGI协议；进入Web框架以后，首先需要经过一系列中间件做必要的处理；然后经过视图层处理逻辑；再经过模型层和数据库通信。我们看到，中间件是所有步骤都需要用的，视图层往往也需要使用多个模型层。

线性的模型实现比较简单，根据固定的应用场景可以把触发器编排好即可。而非线性的场景则比较复杂了，需要开发者自己设置依赖关系。那么，有没有一种通用的解决方案呢？

函数编排服务很好地解决了这个问题。通过可视化的面板，开发者可以把函数根据自己的需要设置触发流程，既可以设置简单的线性关系，也可以设置Web服务这种复杂的非线性关系。此外，函数编排往往还和测试和运维工具整合起来，让函数流程变的更容易维护。

回到上面的应用场景，我们可以把上述的一个流程单元用一个函数计算单元实现，然后根据上述的应用场景组成流程即可。

## Serverless应用框架

略。这一部分主要讲一些广义的Serverless解决方案，主要是用来无服务地部署完整应用的（比如Django服务等）。



